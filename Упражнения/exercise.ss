;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Упражнение 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Зад. 1. Да се дефинира процедура (count-digits n), която генерира линейно рекурсивен процес и намира броя на цифрите на дадено естествено число n. 
;Зад. 2. Да се дефинира процедура (sum-digits n), която генерира линейно рекурсивен процес и намира сумата от цифрите на дадено естествено число n. 
;Зад. 3. Да се дефинира процедура (pow x n), която генерира линейно рекурсивен процес и намира xn, където x е реално, а n - естествено число. 
;Зад. 4. Да се дефинира процедура (sum-digits n), която генерира линейно итеративен процес и намира сумата от цифрите на дадено естествено число n. 
;Зад. 5. Да се дефинира процедура (reverse n), която генерира линейно итеративен процес и по дадено естествено число n намира числото,
;записано със същите цифри, но в обратен ред. 
;Зад. 6. Да се дефинира предикат (prime? n), който проверява дали дадено естествено число n е просто. Забележка: Числото 1 не е нито просто, нито съставно. 
;Композиция на две едноаргументни функции. n-кратна композиция на дадена функция 

#lang racket

;зад 1
(define (count-digits n)
  (if (< (quotient n 10) 1) 1 (+ 1 (count-digits (quotient n 10)))))
      
;зад 2
(define (sum-digits n)
  (if (< (quotient n 10) 1) n (+ (remainder n 10) (sum-digits (quotient n 10)))))
                
;зад 3
(define (pow x n)
  (cond ((= n 0) 1)
        ((= n 1) x)
        (else (* x (pow x (- n 1))))))
;зад 4
(define (sum-digitsI n)
  (define (sum-iter sum i number)
    (if (< i (count-digits n))(sum-iter (+ sum (remainder number 10)) (+ i 1) (quotient number 10)) sum))
  (sum-iter 0 0 n)
  )

;зад 5
(define (reverse n)
  (define (reverse-iter newNum num i)
    (if (= i 0) newNum (reverse-iter (+ newNum (* (remainder num 10) (pow 10 (- i 1)))) (quotient num 10) (- i 1))))
  (reverse-iter 0 n (count-digits n))
  )

;зад 6
(define (prime? n)
  (define (prime-iter sumOfDiv i)
    (cond 
      ((> i n) (if (= sumOfDiv (+ 1 n))true false))
      ((= (remainder n i) 0) (prime-iter (+ sumOfDiv  i) (+ i 1)))
      (else (prime-iter sumOfDiv (+ i 1)))
      )
    )
  (prime-iter 0 1)
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Упражнение 3 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Зад. 1. Да се дефинира предикат, който проверява дали естественото число n е автоморфно, т.е. дали n2 завършва на n 
;(например 25 е автоморфно число, защото 252 = 625 завършва на 25). 
;Зад. 2. Да се дефинира процедура, която по дадени естествени числа a и b намира: а) най-големия общ делител на a и b, като генерира линейно рекурсивен процес.
;Да се оцени с модела на средите примерно обръщение към процедурата. б) най-малкото общо кратно на a и b. 
;Зад. 3. Нека d е функция, която на всяко естествено число съпоставя броя на естествените му делители. Да се дефинира процедура, която:
;а) генерира линейно итеративен процес и намира d(k) по дадено k. Да се оцени с модела на средите примерно обръщение към процедурата.
;б) намира сумата на всички естествени числа k от интервала [a, b], които имат брой делители d(k) = n, където n, a и b са дадени естествени числа. 
;Зад. 4. Да се дефинира: а) предикат (palindrome? n), който проверява дали естественото число n е палиндром, 
;т.е. дали четено отляво надясно и отдясно наляво е едно и също число. б) процедура (count-palindromes a b), 
;която намира броя на палиндромите в интервала [a, b], където a и b са естествени числа. 
;Зад. 5. Да се дефинира процедура, която пресмята ex по формулата на Тейлър. 
;Зад. 6. Да се дефинира предикат (substr? a b), който проверява дали a е подниз на b, където a и b са естествени числа (например 123 е подниз на 5123783). 


;зад 1
(define (avtomorf? n)
  (= (remainder (* n n) (pow 10 (count-digits n))) n))

;зад 2
;a)
(define (gcd a b)
  (cond ((= a b)a)
        ((> a b) (gcd (- a b) b))
        ((< a b)(gcd (- b a) a))
        )
  )
;б)
(define (lcm a b)
  (/ (* a b) (gcd a b)))

;зад 3
;а)
(define (d k)
  (define (d-iter i counter)
    (cond ((> i k) counter)
          ((=(remainder k i)0)(d-iter (+ i 1) (+ counter 1)))
          (else (d-iter (+ i 1) counter)))
    )
  (d-iter 1 0)
  )
;б) намира сумата на всички естествени числа k от интервала [a, b], които имат брой делители d(k) = n, където n, a и b са дадени естествени числа. 
(define (asdf a b n)
  (define (iter i sum)
    (cond ((> i b) sum)
          ((= n (d i)) (iter (+ i 1) (+ sum i)))
          (else (iter (+ i 1) sum))
          )
    )
  (iter a 0)
  )
;зад 4   1221, 313, 111, ....
(define (palindrome? x)
  (if (= (reverse x) x) true false))

(define (count-pal a b)
  (define (iter i counter)
    (cond ((> i b) counter)
          ((palindrome? i) (iter (+ 1 i) (+ 1 counter)))
          (else (iter (+ 1 i) counter))
          )
    )
  (iter a 0)
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Упражнение 4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Зад. 1. Да се дефинира процедура от по-висок ред (difference F a b), която по дадени едноаргументна реална функция F и две реални числа a и b намира разликата F(b) - F(a). Да се оцени примерно орбъщение към процедурата. 
;Зад. 2. Чрез използване на lambda израз да се дефинира процедурен обект, който е еквивалентен на f, ако имаме дефиницията (define (f x) (* 2 x)). 
;Зад. 3. Да се дефинира процедура от по-висок ред (composition f g), която намира композицията на едноаргументните реални функции f и g. 
;Зад. 4. Да се дефинира процедура от по-висок ред (derive f eps), която намира първа производна на едноаргументната реална функция f с точност eps. 
;Зад. 5. Да се дефинира процедура от по-висок ред (derive2 f eps), която намира втора производна на едноаргументната реална функция f с точност eps. 
;Зад. 6. Да се дефинира процедура от по-висок ред (derive-n f n eps), която намира n- та производна на едноаргументната реална функция f с точност eps. 
;Зад. 7. Да се дефинира процедура от по-висок ред (repeated f n), която намира n- кратна композиция на едноаргументната реална функция f: а) без използване на процедурата composition от зад. 3; б) с използване на процедурата composition от зад. 3. 
;Зад. 8. Да се дефинират процедури от по-висок ред (derive-x f eps) и (derive-y f eps), които намират съответно първа частна производна по x и първа частна производна по y на двуаргументната реална функция f с точност eps.


;зад 1
(define (difference F a b)
  (- (F b) (F a)))

(define (f1 x)
  (- x 1))

;зад 2
(define (f x) 
  (* 2 x))
(define g
  (lambda(x) (* 2 x)))
;пример (difference (lambda(x)(- x 1)) 0 1)

;зад 3
(define (composition f g)
  (lambda(x) (f (g (x)))))

;зад 4
(define (derive f eps)
  (lambda (x) (/(- (f (+ x eps))(f x)) eps))
  )

((derive (lambda(x)(* x x x)) 0.0001)2)

;зад 5
(define (derive2 f eps)
  (derive (derive f eps) eps))

;зад 6 
(define (deriveN f n eps)
  (if (= n 0)f
      (derive (deriveN f (- n 1) eps) eps)))
;зад 7
(define (repeated f n)
  (lambda (x)
    (if (= n 0) x
      (f((repeated f (- n 1)) x)))))

(define (repeated2 f n)
  (if (= n 0)(lambda (x) x)
      (lambda (x)(f((repeated2 f (- n 1)) x)))))

;зад 8
(define (derive-x f eps)
  (lambda (x y)(/ ((f (+ x eps) y)(f x y))
                  eps)))
(define (derive-y f eps)
  (lambda (x y)(/ ((f x (+ y eps))(f x y))
                  eps)))